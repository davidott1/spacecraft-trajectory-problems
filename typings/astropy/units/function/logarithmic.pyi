"""
This type stub file was generated by pyright.
"""

from astropy.utils.compat.numpycompat import NUMPY_LT_2_0
from .core import FunctionQuantity, FunctionUnitBase

__all__ = ["LogUnit", "MagUnit", "DexUnit", "DecibelUnit", "LogQuantity", "Magnitude", "Decibel", "Dex", "STmag", "ABmag", "M_bol", "m_bol"]
class LogUnit(FunctionUnitBase):
    """Logarithmic unit containing a physical one.

    Usually, logarithmic units are instantiated via specific subclasses
    such `~astropy.units.MagUnit`, `~astropy.units.DecibelUnit`, and
    `~astropy.units.DexUnit`.

    Parameters
    ----------
    physical_unit : `~astropy.units.Unit` or `string`
        Unit that is encapsulated within the logarithmic function unit.
        If not given, dimensionless.

    function_unit :  `~astropy.units.Unit` or `string`
        By default, the same as the logarithmic unit set by the subclass.

    """
    def from_physical(self, x): # -> float | NDArray[floating[Any]] | complex:
        """Transformation from value in physical to value in logarithmic units.
        Used in equivalency.
        """
        ...
    
    def to_physical(self, x): # -> float | NDArray[floating[Any]] | complex:
        """Transformation from value in logarithmic to value in physical units.
        Used in equivalency.
        """
        ...
    
    def __neg__(self): # -> Self:
        ...
    
    def __add__(self, other): # -> _NotImplementedType | Self:
        ...
    
    def __radd__(self, other): # -> _NotImplementedType | Self:
        ...
    
    def __sub__(self, other): # -> _NotImplementedType | Self:
        ...
    
    def __rsub__(self, other): # -> _NotImplementedType | Self:
        ...
    


class MagUnit(LogUnit):
    """Logarithmic physical units expressed in magnitudes.

    Parameters
    ----------
    physical_unit : `~astropy.units.Unit` or `string`
        Unit that is encapsulated within the magnitude function unit.
        If not given, dimensionless.

    function_unit :  `~astropy.units.Unit` or `string`
        By default, this is ``mag``, but this allows one to use an equivalent
        unit such as ``2 mag``.
    """
    ...


class DexUnit(LogUnit):
    """Logarithmic physical units expressed in magnitudes.

    Parameters
    ----------
    physical_unit : `~astropy.units.Unit` or `string`
        Unit that is encapsulated within the magnitude function unit.
        If not given, dimensionless.

    function_unit :  `~astropy.units.Unit` or `string`
        By default, this is ``dex``, but this allows one to use an equivalent
        unit such as ``0.5 dex``.
    """
    def to_string(self, format=...): # -> str:
        ...
    


class DecibelUnit(LogUnit):
    """Logarithmic physical units expressed in dB.

    Parameters
    ----------
    physical_unit : `~astropy.units.Unit` or `string`
        Unit that is encapsulated within the decibel function unit.
        If not given, dimensionless.

    function_unit :  `~astropy.units.Unit` or `string`
        By default, this is ``dB``, but this allows one to use an equivalent
        unit such as ``2 dB``.
    """
    ...


class LogQuantity(FunctionQuantity):
    """A representation of a (scaled) logarithm of a number with a unit.

    Parameters
    ----------
    value : number, `~astropy.units.Quantity`, `~astropy.units.LogQuantity`, or sequence of quantity-like.
        The numerical value of the logarithmic quantity. If a number or
        a `~astropy.units.Quantity` with a logarithmic unit, it will be
        converted to ``unit`` and the physical unit will be inferred from
        ``unit``.  If a `~astropy.units.Quantity` with just a physical unit,
        it will converted to the logarithmic unit, after, if necessary,
        converting it to the physical unit inferred from ``unit``.

    unit : str, `~astropy.units.UnitBase`, or `~astropy.units.FunctionUnitBase`, optional
        For an `~astropy.units.FunctionUnitBase` instance, the
        physical unit will be taken from it; for other input, it will be
        inferred from ``value``. By default, ``unit`` is set by the subclass.

    dtype : `~numpy.dtype`, optional
        The ``dtype`` of the resulting Numpy array or scalar that will
        hold the value.  If not provided, is is determined automatically
        from the input value.

    copy : bool, optional
        If `True` (default), then the value is copied.  Otherwise, a copy will
        only be made if ``__array__`` returns a copy, if value is a nested
        sequence, or if a copy is needed to satisfy an explicitly given
        ``dtype``.  (The `False` option is intended mostly for internal use,
        to speed up initialization where a copy is known to have been made.
        Use with care.)

    Examples
    --------
    Typically, use is made of an `~astropy.units.FunctionQuantity`
    subclass, as in::

        >>> import astropy.units as u
        >>> u.Magnitude(-2.5)
        <Magnitude -2.5 mag>
        >>> u.Magnitude(10.*u.count/u.second)
        <Magnitude -2.5 mag(ct / s)>
        >>> u.Decibel(1.*u.W, u.DecibelUnit(u.mW))  # doctest: +FLOAT_CMP
        <Decibel 30. dB(mW)>

    """
    _unit_class = LogUnit
    def __add__(self, other): # -> Self | Quantity | Any:
        ...
    
    def __radd__(self, other): # -> Self | Quantity | Any:
        ...
    
    def __iadd__(self, other): # -> Self:
        ...
    
    def __sub__(self, other): # -> Self | Quantity | Any:
        ...
    
    def __rsub__(self, other): # -> Self | Quantity | Any:
        ...
    
    def __isub__(self, other): # -> Self:
        ...
    
    def __mul__(self, other): # -> Self | Quantity | Any:
        ...
    
    def __rmul__(self, other): # -> Self | Quantity | Any:
        ...
    
    def __imul__(self, other): # -> Self:
        ...
    
    def __truediv__(self, other): # -> Self | Quantity | Any:
        ...
    
    def __itruediv__(self, other): # -> Self:
        ...
    
    def __pow__(self, other): # -> _NotImplementedType | Self | Quantity | Any:
        ...
    
    def __ilshift__(self, other): # -> _NotImplementedType | Self:
        ...
    
    def var(self, axis=..., dtype=..., out=..., ddof=...): # -> list[Any] | tuple[Any, ...] | Any | Self | Quantity:
        ...
    
    def std(self, axis=..., dtype=..., out=..., ddof=...): # -> list[Any] | tuple[Any, ...] | Any | Self | Quantity:
        ...
    
    if NUMPY_LT_2_0:
        def ptp(self, axis=..., out=...): # -> list[Any] | tuple[Any, ...] | Any | Self | Quantity:
            ...
        
    else:
        def __array_function__(self, function, types, args, kwargs): # -> list[Any] | tuple[Any, ...] | Any | Self | Quantity | _NotImplementedType:
            ...
        
    def diff(self, n=..., axis=...): # -> list[Any] | tuple[Any, ...] | Any | Self | Quantity:
        ...
    
    def ediff1d(self, to_end=..., to_begin=...): # -> list[Any] | tuple[Any, ...] | Any | Self | Quantity:
        ...
    
    _supported_functions = ...


class Dex(LogQuantity):
    _unit_class = DexUnit


class Decibel(LogQuantity):
    _unit_class = DecibelUnit


class Magnitude(LogQuantity):
    _unit_class = MagUnit


STmag = ...
ABmag = ...
M_bol = ...
m_bol = ...
