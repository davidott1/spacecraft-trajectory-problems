"""
This type stub file was generated by pyright.
"""

import numpy as np
from numpy.lib import recfunctions as rfn
from astropy.utils.compat import NUMPY_LT_1_23, NUMPY_LT_2_0

"""Helpers for overriding numpy functions.

We override numpy functions in `~astropy.units.Quantity.__array_function__`.
In this module, the numpy functions are split in four groups, each of
which has an associated `set` or `dict`:

1. SUBCLASS_SAFE_FUNCTIONS (set), if the numpy implementation
   supports Quantity; we pass on to ndarray.__array_function__.
2. FUNCTION_HELPERS (dict), if the numpy implementation is usable
   after converting quantities to arrays with suitable units,
   and possibly setting units on the result.
3. DISPATCHED_FUNCTIONS (dict), if the function makes sense but
   requires a Quantity-specific implementation
4. UNSUPPORTED_FUNCTIONS (set), if the function does not make sense.

For the FUNCTION_HELPERS `dict`, the value is a function that does the
unit conversion.  It should take the same arguments as the numpy
function would (though one can use ``*args`` and ``**kwargs``) and
return a tuple of ``args, kwargs, unit, out``, where ``args`` and
``kwargs`` will be will be passed on to the numpy implementation,
``unit`` is a possible unit of the result (`None` if it should not be
converted to Quantity), and ``out`` is a possible output Quantity passed
in, which will be filled in-place.

For the DISPATCHED_FUNCTIONS `dict`, the value is a function that
implements the numpy functionality for Quantity input. It should
return a tuple of ``result, unit, out``, where ``result`` is generally
a plain array with the result, and ``unit`` and ``out`` are as above.
If unit is `None`, result gets returned directly, so one can also
return a Quantity directly using ``quantity_result, None, None``.

"""
if NUMPY_LT_2_0:
    ...
else:
    ...
ARRAY_FUNCTION_ENABLED = ...
SUBCLASS_SAFE_FUNCTIONS = ...
FUNCTION_HELPERS = ...
DISPATCHED_FUNCTIONS = ...
UNSUPPORTED_FUNCTIONS = ...
if NUMPY_LT_2_0:
    ...
else:
    ...
if NUMPY_LT_2_0:
    ...
TBD_FUNCTIONS = ...
IGNORED_FUNCTIONS = ...
if NUMPY_LT_1_23:
    ...
class FunctionAssigner:
    def __init__(self, assignments) -> None:
        ...
    
    def __call__(self, f=..., helps=..., module=...): # -> partial[Any]:
        """Add a helper to a numpy function.

        Normally used as a decorator.

        If ``helps`` is given, it should be the numpy function helped (or an
        iterable of numpy functions helped).

        If ``helps`` is not given, it is assumed the function helped is the
        numpy function with the same name as the decorated function.
        """
        ...
    


function_helper = ...
dispatched_function = ...
@function_helper(helps=np.copy, np.real_if_close, np.sort_complex, np.resize, np.fft.fft, np.fft.ifft, np.fft.rfft, np.fft.irfft, np.fft.fft2, np.fft.ifft2, np.fft.rfft2, np.fft.irfft2, np.fft.fftn, np.fft.ifftn, np.fft.rfftn, np.fft.irfftn, np.fft.hfft, np.fft.ihfft, np.linalg.eigvals, np.linalg.eigvalsh | np.asfarray if NUMPY_LT_2_0 else set())
def invariant_a_helper(a, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], Any, None]:
    ...

@function_helper(helps=np.tril, np.triu)
def invariant_m_helper(m, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], Any, None]:
    ...

@function_helper(helps=np.fft.fftshift, np.fft.ifftshift)
def invariant_x_helper(x, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], Any, None]:
    ...

@function_helper(helps=np.ones_like, np.zeros_like)
def like_helper(a, *args, **kwargs): # -> tuple[tuple[Any, Any, Any, Any, *tuple[Any, ...]] | tuple[Any] | tuple[Any, Any] | tuple[Any, Any, Any], dict[str, Any], Any | None, None]:
    ...

@function_helper
def sinc(x): # -> tuple[tuple[Any], dict[Any, Any], CompositeUnit, None]:
    ...

@dispatched_function
def unwrap(p, discont=..., axis=...): # -> tuple[Any, <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def argpartition(a, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], None, None]:
    ...

@function_helper
def full_like(a, fill_value, *args, **kwargs): # -> tuple[tuple[Any, Any, *tuple[Any, ...]], dict[str, Any], Any | None, None]:
    ...

@function_helper
def putmask(a, mask, values): # -> tuple[tuple[ndarray[Any, Any], Any, Any | NDArray[Any] | ndarray[Any, Any]], dict[Any, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None] | tuple[tuple[Any, Any, ndarray[Any, Any] | Any], dict[Any, Any], None, None]:
    ...

@function_helper
def place(arr, mask, vals): # -> tuple[tuple[ndarray[Any, Any], Any, Any | NDArray[Any] | ndarray[Any, Any]], dict[Any, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None] | tuple[tuple[Any, Any, ndarray[Any, Any] | Any], dict[Any, Any], None, None]:
    ...

@function_helper
def copyto(dst, src, *args, **kwargs): # -> tuple[tuple[ndarray[Any, Any], Any | NDArray[Any] | ndarray[Any, Any], *tuple[Any, ...]], dict[str, Any], None, None] | tuple[tuple[Any, ndarray[Any, Any] | Any, *tuple[Any, ...]], dict[str, Any], None, None]:
    ...

@function_helper
def nan_to_num(x, copy=..., nan=..., posinf=..., neginf=...): # -> tuple[tuple[Any], dict[str, Any | None], Any, None]:
    ...

@function_helper
def concatenate(arrays, axis=..., out=..., **kwargs): # -> tuple[tuple[tuple[Any] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ...]], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, Quantity | None]:
    ...

@dispatched_function
def block(arrays): # -> tuple[NDArray[Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def choose(a, choices, out=..., **kwargs): # -> tuple[tuple[Any, tuple[Any] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ...]], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, Quantity | None]:
    ...

@function_helper
def select(condlist, choicelist, default=...): # -> tuple[tuple[Any, tuple[Any] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ...], Any | NDArray[Any] | ndarray[Any, Any] | int], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, Quantity | None]:
    ...

@dispatched_function
def piecewise(x, condlist, funclist, *args, **kw): # -> tuple[NDArray[float64], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def append(arr, values, *args, **kwargs): # -> tuple[tuple[Any, ...] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ...], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def insert(arr, obj, values, *args, **kwargs): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], Any, Any | NDArray[Any] | ndarray[Any, Any], *tuple[Any, ...]], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def pad(array, pad_width, mode=..., **kwargs): # -> tuple[tuple[Any, Any, str], dict[str, Any], Any, None]:
    ...

@function_helper
def where(condition, *args): # -> tuple[tuple[Any, Any] | tuple[Any, *tuple[Any | NDArray[Any] | ndarray[Any, Any], ...]], dict[Any, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper(helps=np.quantile, np.nanquantile)
def quantile(a, q, *args, _q_unit=..., **kwargs): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], ndarray[Any, Any] | Any, Any, *tuple[Any, ...]] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ndarray[Any, Any] | Any] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ndarray[Any, Any] | Any, Any], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, Quantity | None]:
    ...

@function_helper(helps=np.percentile, np.nanpercentile)
def percentile(a, q, *args, **kwargs): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], ndarray[Any, Any] | Any, Any, *tuple[Any, ...]] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ndarray[Any, Any] | Any] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ndarray[Any, Any] | Any, Any], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, Quantity | None]:
    ...

@function_helper
def nanmedian(a, axis=..., out=..., **kwargs): # -> tuple[tuple[Any] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ...], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, Quantity | None]:
    ...

@function_helper
def count_nonzero(a, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], None, None]:
    ...

@function_helper(helps=np.isclose, np.allclose)
def close(a, b, rtol=..., atol=..., *args, **kwargs): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], Any | NDArray[Any] | ndarray[Any, Any], float, Any, *tuple[Any, ...]], dict[str, Any], None, None]:
    ...

@dispatched_function
def array_equal(a1, a2, equal_nan=...): # -> tuple[Literal[False], None, None] | tuple[bool, None, None]:
    ...

@dispatched_function
def array_equiv(a1, a2): # -> tuple[Literal[False], None, None] | tuple[bool, None, None]:
    ...

@function_helper(helps=np.dot, np.outer)
def dot_like(a, b, out=...): # -> tuple[tuple[ndarray[Any, Any], ...], dict[Any, Any], Any | _NotImplementedType | StructuredUnit | Quantity | <subclass of Unit and StructuredUnit> | UnitBase | Unit | CompositeUnit | UnrecognizedUnit, Quantity] | tuple[tuple[ndarray[Any, Any], ndarray[Any, Any]], dict[Any, Any], Any | _NotImplementedType | StructuredUnit | Quantity | <subclass of Unit and StructuredUnit> | UnitBase | Unit | CompositeUnit | UnrecognizedUnit, None]:
    ...

@function_helper(helps=np.cross, np.inner, np.vdot, np.tensordot, np.kron, np.correlate, np.convolve)
def cross_like(a, b, *args, **kwargs): # -> tuple[tuple[ndarray[Any, Any], ndarray[Any, Any], *tuple[Any, ...]], dict[str, Any], Any | _NotImplementedType | StructuredUnit | Quantity | <subclass of Unit and StructuredUnit> | UnitBase | Unit | CompositeUnit | UnrecognizedUnit, None]:
    ...

@function_helper
def einsum(subscripts, *operands, out=..., **kwargs): # -> tuple[tuple[str, *tuple[ndarray[Any, Any], ...]], dict[str, Any], Any, Quantity | None]:
    ...

@function_helper
def bincount(x, weights=..., minlength=...): # -> tuple[tuple[Any, Any, int], dict[Any, Any], Any, None]:
    ...

@function_helper
def digitize(x, bins, *args, **kwargs): # -> tuple[tuple[Any, ...] | tuple[Any | NDArray[Any] | ndarray[Any, Any], ...], dict[str, Any], None, None]:
    ...

@function_helper
def histogram(a, bins=..., range=..., weights=..., density=...): # -> tuple[tuple[Any, ndarray[Any, Any] | Any | int | <subclass of int and str>, ndarray[Any, Any] | Any | None], dict[str, Any], tuple[<subclass of Unit and StructuredUnit> | CompositeUnit | Quantity | Any | _NotImplementedType | StructuredUnit | Unit | UnitBase | Self | None, <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None], None]:
    ...

@function_helper(helps=np.histogram_bin_edges)
def histogram_bin_edges(a, bins=..., range=..., weights=...): # -> tuple[tuple[Any, ndarray[Any, Any] | Any | int | <subclass of int and str>, ndarray[Any, Any] | Any | None, Any | None], dict[Any, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def histogram2d(x, y, bins=..., range=..., weights=..., density=...): # -> tuple[tuple[Any, Any, list[ndarray[Any, Any] | Any] | ndarray[Any, Any] | Any | int, tuple[ndarray[Any, Any] | Any, ...] | None], dict[str, Any], tuple[<subclass of Unit and StructuredUnit> | CompositeUnit | Quantity | Any | _NotImplementedType | StructuredUnit | Unit | UnitBase | Self | None, <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | Any | None], None]:
    ...

@function_helper
def histogramdd(sample, bins=..., range=..., weights=..., density=...): # -> tuple[tuple[Quantity | list[Any], list[ndarray[Any, Any] | Any] | int, tuple[ndarray[Any, Any] | Any, ...] | None], dict[str, Any], tuple[Any | <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, Any | list[<subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None]], None]:
    ...

@function_helper
def diff(a, n=..., axis=..., prepend=..., append=...): # -> tuple[tuple[Any, int, int, ndarray[Any, Any] | Any, ndarray[Any, Any] | Any], dict[Any, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def gradient(f, *varargs, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]] | tuple[Any, *tuple[Quantity, ...]], dict[str, Any], Any | <subclass of Unit and StructuredUnit> | CompositeUnit | Self | Quantity | _NotImplementedType | StructuredUnit | Unit | UnitBase | list[Any | <subclass of Unit and StructuredUnit> | CompositeUnit | Self | Quantity | _NotImplementedType | StructuredUnit | Unit | UnitBase] | list[<subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None] | None, None]:
    ...

@function_helper
def logspace(start, stop, *args, **kwargs): # -> tuple[tuple[Any, Any, *tuple[Any, ...]], dict[str, Any], Any, None]:
    ...

@function_helper
def geomspace(start, stop, *args, **kwargs): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], Any | NDArray[Any] | ndarray[Any, Any], *tuple[Any, ...]], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def interp(x, xp, fp, *args, **kwargs): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], Any | NDArray[Any] | ndarray[Any, Any], Any, *tuple[Any, ...]], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper
def unique(ar, return_index=..., return_inverse=..., return_counts=..., axis=..., **kwargs): # -> tuple[tuple[Any, bool, bool, bool, Any | None], dict[str, Any], list[Any] | Any, None]:
    ...

@function_helper
def intersect1d(ar1, ar2, assume_unique=..., return_indices=...): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], Any | NDArray[Any] | ndarray[Any, Any], bool, bool], dict[Any, Any], list[Any] | <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper(helps=(np.setxor1d, np.union1d, np.setdiff1d))
def twosetop(ar1, ar2, *args, **kwargs): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], Any | NDArray[Any] | ndarray[Any, Any], *tuple[Any, ...]], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None, None]:
    ...

@function_helper(helps=(np.isin, np.in1d))
def setcheckop(ar1, ar2, *args, **kwargs): # -> tuple[tuple[Any | NDArray[Any] | ndarray[Any, Any], Any | NDArray[Any] | ndarray[Any, Any], *tuple[Any, ...]], dict[str, Any], None, None]:
    ...

@dispatched_function
def apply_over_axes(func, a, axes): # -> tuple[Any | NDArray[Any], None, None]:
    ...

@dispatched_function
def array_repr(arr, *args, **kwargs): # -> tuple[str, None, None]:
    ...

@dispatched_function
def array_str(arr, *args, **kwargs): # -> tuple[Any, None, None]:
    ...

@function_helper
def array2string(a, *args, **kwargs): # -> tuple[tuple[Any, Any, Any, Any, Any, Any, Any, Any, *tuple[Any, ...]] | tuple[Any] | tuple[Any, Any] | tuple[Any, Any, Any] | tuple[Any, Any, Any, Any] | tuple[Any, Any, Any, Any, Any] | tuple[Any, Any, Any, Any, Any, Any] | tuple[Any, Any, Any, Any, Any, Any, Any], dict[str, Any], None, None]:
    ...

@function_helper
def diag(v, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], Any, None]:
    ...

@function_helper(module=np.linalg)
def svd(a, full_matrices=..., compute_uv=..., hermitian=...): # -> tuple[tuple[Any, bool, bool, bool], dict[Any, Any], tuple[None, Any, None] | Any, None]:
    ...

@function_helper(module=np.linalg)
def matrix_rank(M, tol=..., *args, **kwargs): # -> tuple[tuple[Any, Any | None, *tuple[Any, ...]], dict[str, Any], None, None]:
    ...

@function_helper(helps=np.linalg.inv, np.linalg.tensorinv)
def inv(a, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], Any, None]:
    ...

if NUMPY_LT_2_0:
    @function_helper(module=np.linalg)
    def pinv(a, rcond=..., *args, **kwargs): # -> tuple[tuple[Any, Any, *tuple[Any, ...]], dict[str, Any], Any, None]:
        ...
    
else:
    @function_helper(module=np.linalg)
    def pinv(a, rcond=..., hermitian=..., *, rtol=...): # -> tuple[tuple[Any], dict[str, Any | None], Any, None]:
        ...
    
@function_helper(module=np.linalg)
def det(a): # -> tuple[tuple[Any], dict[Any, Any], Any, None]:
    ...

@function_helper(helps=np.linalg.solve, np.linalg.tensorsolve)
def solve(a, b, *args, **kwargs): # -> tuple[tuple[ndarray[Any, Any], ndarray[Any, Any], *tuple[Any, ...]], dict[str, Any], Any | <subclass of Unit and StructuredUnit> | CompositeUnit | Self | Quantity | _NotImplementedType | StructuredUnit | Unit | UnitBase, None]:
    ...

@function_helper(module=np.linalg)
def lstsq(a, b, rcond=...): # -> tuple[tuple[ndarray[Any, Any], ndarray[Any, Any], Any | str | None], dict[Any, Any], tuple[Any | <subclass of Unit and StructuredUnit> | CompositeUnit | Self | Quantity | _NotImplementedType | StructuredUnit | Unit | UnitBase, Any | CompositeUnit, None, <subclass of Unit and StructuredUnit> | StructuredUnit | Unit | UnitBase | None], None]:
    ...

@function_helper(module=np.linalg)
def norm(x, ord=..., *args, **kwargs): # -> tuple[tuple[Any, Any | int | None, *tuple[Any, ...]], dict[str, Any], CompositeUnit | Any, None]:
    ...

@function_helper(module=np.linalg)
def matrix_power(a, n): # -> tuple[tuple[Any, Any], dict[Any, Any], Any, None]:
    ...

if NUMPY_LT_2_0:
    @function_helper(module=np.linalg)
    def cholesky(a): # -> tuple[tuple[Any], dict[Any, Any], Any, None]:
        ...
    
else:
    @function_helper(module=np.linalg)
    def cholesky(a, /, *, upper=...): # -> tuple[tuple[Any], dict[str, bool], Any, None]:
        ...
    
@function_helper(module=np.linalg)
def qr(a, mode=...): # -> tuple[tuple[Any, str], dict[Any, Any], Any | tuple[CompositeUnit, Any] | None, None]:
    ...

@function_helper(helps=np.linalg.eig, np.linalg.eigh)
def eig(a, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], tuple[Any, CompositeUnit], None]:
    ...

if not NUMPY_LT_2_0:
    @function_helper(module=np.linalg)
    def outer(a, b, /): # -> tuple[tuple[ndarray[Any, Any], ndarray[Any, Any]], dict[Any, Any], Any | _NotImplementedType | StructuredUnit | Quantity | <subclass of Unit and StructuredUnit> | UnitBase | Unit | CompositeUnit | UnrecognizedUnit, None]:
        ...
    
@function_helper(module=np.lib.recfunctions)
def structured_to_unstructured(arr, *args, **kwargs): # -> tuple[tuple[Any, *tuple[Any, ...]], dict[str, Any], Any, None]:
    """
    Convert a structured quantity to an unstructured one.
    This only works if all the units are compatible.

    """
    ...

@function_helper(module=np.lib.recfunctions)
def unstructured_to_structured(arr, dtype, *args, **kwargs): # -> tuple[tuple[Any, Any, *tuple[Any, ...]], dict[str, Any], <subclass of Unit and StructuredUnit> | StructuredUnit, None]:
    ...

@function_helper(helps=rfn.merge_arrays)
def merge_arrays(seqarrays, fill_value=..., flatten=..., usemask=..., asrecarray=...): # -> tuple[tuple[tuple[Any, ...] | tuple[Any]], dict[str, int], <subclass of Unit and StructuredUnit> | StructuredUnit, None]:
    """Merge structured Quantities field by field.

    Like :func:`numpy.lib.recfunctions.merge_arrays`. Note that ``usemask`` and
    ``asrecarray`` are not supported at this time and will raise a ValueError if
    not `False`.
    """
    ...

